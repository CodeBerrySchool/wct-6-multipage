/*------------------------------------*\
  #HELPER-STYLES
\*------------------------------------*/

* {
  box-sizing: border-box;
}

/* [x] The normalize.css has a top and bottom margin on h1-6 and p elements.
These helpers nullify that so it won't interfere with the grid. */

h1,
h2,
p {
  margin: 0;
}

/* This rule set extends the uniform vertical rhythm to the headings and
paragraphs. Not sure if  it belongs here or to the layout grid.  */

h1,
h2,
p {
  margin-bottom: 1.5rem;
}



/*------------------------------------*\
  #LAYOUT-STYLES
\*------------------------------------*/

/*
We use the following classes to create a very basic grid.

The .layout element creates a fluid container which is the immediate child of
the body. Inside that there is two kinds of layout containers: a 100% wide and
a 90% wide one.

The grid is capable of creating a three-column layout. The .layout__item--one-
third div takes up the 30%  of the available space and is floated to the left,
creating the three-column layout. It is only triggered upwards from 768px
thanks to a media query. Floats are cleared via a pseudo- element and a
dedicated class.

The vertical rhythm is established through a single margin-bottom declaration
on the .layout__item class. Since this class is present on every grid item, it
can create a uniform margin spacing.

The three column layout needs gutters. This is solved through margin
declarations for the first and last column. The width of the columns is
established as 30%, the remaining 9.9% is divided between a right margin for
the first and a left margin for the last column. (Note: This could've been
done way more easier through flexbox with a space-between value.)

The margin-bottom: 0; declaration on the last layout__item ensures that the
end of the page doesn't have extra margins. You may need to check the last
item  in the last container though. It could add extra margins on its own
which you have to handle differently. 

The .layout__item--nested modifier strips the container of its bottom margin.
This is useful because when you have a container inside another container
their bottom margins compound.  With this modifier you can maintain the
unified vertical rhythm. 

However this poses a problem when the nested containers are stacked and they
have no margin. The media query takes care of that by switching  back the
original margin on the nested elements but only in mobile layout.

The .layout__item--two-thirds is in a media query. In this case it solves  the
problem of the responsive embedded iframe that is in a 100% wide container.
When the screen gets large enough, the query triggers and switches the
embedded  iframe to a centered 66.6% wide container. For this to work the
class must be  placed below the full-width class (CSS cascading).

The one-fourth creates a 4-column view. Its margin is the same as the 3 column. 

*/

.layout {
  margin: 0;
  padding: 0;
  background: lightblue;
}


  .layout__item {
    margin-bottom: 1.5rem;
  }


  .layout__item--fullwidth {
    width: 100%;
    background: lightgreen;

  }


  .layout__item--ninetenth {
    width: 90%;
    max-width: 1600px;
    margin: 0 auto 1.5rem;
    background: lightyellow;
  }


  @media (min-width: 768px) {

    .layout__item--two-thirds {
      width: 66.6%;
      max-width: max-width: 1280px;
      margin: 0 auto 1.5rem;
      background: gold;
    }

  }


  @media (min-width: 768px) {

    .layout__item--one-third {
      width: 30%;
      float: left;
      overflow: hidden;
      background: rebeccapurple;
    }

    .layout__item--one-third:first-child {
      margin-right: 4.95%;
    }

    .layout__item--one-third:last-child {
      margin-left: 4.95%;
    }

  }

  @media (min-width: 768px) {

    .layout__item--one-fourth {
      width: 21.2875%;
      float: left;
      overflow: hidden;
      background: rebeccapurple;
      margin-right: 4.95%;
    }

    .layout__item--one-fourth:last-child {
      margin-right: 0;
    }

  }

  .layout__item--clearfix::after {
    content: "";
    clear: both;
    display: block;
  }


  .layout__item--nested {
    margin-bottom: 0;
  }

  @media (max-width: 768px) {
    
    .layout__item--nested {
      margin-bottom: 1.5rem;
    }

  }


  .layout__item:last-child {
    margin-bottom: 0;
  }


/*------------------------------------*\
  #TESTIMONIAL-STYLES
\*------------------------------------*/

.testimonial {
  width: 100%;
  background: lightcoral;
}

  .testimonial__image {
    width: 100%;
  }





/*------------------------------------*\
  #TEAM-CARD-STYLES
\*------------------------------------*/

.team-card {
  width: 100%;
  background: lightcoral;
}

  .team-card__image {
    width: 100%;
  }





/*------------------------------------*\
  #MEDIA-OBJECT-STYLES
\*------------------------------------*/

/*  This section creates a responsive wrapper for iframes. Since iframes
arrive in a fixed container,  we need to make them responsive somehow. This
method requires a wrapper around the iframe (.responsive-media)  and a class
on the iframe itself (.responsive-media__embed). The wrapper has an intrinsic
ratio  using a padding in percentages which corresponds to the 16:9 ratio of
the iframe. The wrapper essentially forces  the iframe to recalculate its
height on every viewport size.; 

The videos's aspect ration is 06:9 but that's not suitable for the map embeds
this is why we have the .responsive-media--map modifier.
*/

.responsive-media {
  position: relative;
  padding-bottom: 56.25%; /* 16:9 aspect ratio */
  height: 0;
}

.responsive-media--map {
  padding-bottom: 38.1944%;
}

  .responsive-media__embed {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    width: 100%;
  }






/*------------------------------------*\
  #MAIN-HEADER-NAV-STYLES
\*------------------------------------*/

/**
* [1] The .header-main creates an absolutely
* positioned wrapper that serves as a base
* for the whole component. Because it is
* absolutely positioned to the top it defaults
* to the top of the viewport if you don't use
* any other wrappers (or a layout grid). But you
* can include it in a container then it'll adapt
* its dimensions to its constraints.
* Note: you can put it inside a fixed container
* if you want a fixed-to-top navigation.
*
* [2] The z-index is there so we can lay every
* other element onto the wrapper with increased
* indexes.
* 
This position-fix you have to append to the following element in the DOM, 
to prevent the header from overlapping the content.
The margin has to be the same as the height of the header.
*/

.header-main { /*[1]*/
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100px;
  z-index: 2; /*[2]*/
}

.header-main__position-fix {
  margin-top: 100px;
}


/**
* [3] The navigation element is the one that gives
* the physical appearance of the component in its
* closed state. It's positioned onto the
* .header-main element so it hides it.
* It will also serve as the dropdown menu. In its
* closed state it has fix height but when opened
* it extends to 100vh therefore expanding onto
* the rest of the page creating the menu.

* [4] These properties position the nav relatively
* to its container, the .header-main. It furthers
* the elements portability since its independent
* of its surroundings.
*
* [5] The width: 100%; stretches the nav element
* to fill its container. The fixed height is not
* a problem when it comes to responsivity
* since nav heights usually don't change.
*
* [6] It has a z-index of 3 which puts it above
* the .header-main but below the following
* elements. Thus it creates a canvas for them.
*
* [7] The nav will contain links that could
* potentially overflow the element. This property
* takes care of that.
*
* [8] The transition and transition delay
* properties are part of the animation structure.
* They are creating a prolonged, animated switch
* between the 100px and 100vh states.
*/

.header-main__nav-mobile { /*[3]*/
  background: firebrick;
  position: absolute; /*[4]*/
  top: 0; /*[4]*/
  left: 0; /*[4]*/
  width: 100%; /*[5]*/
  height: 100px; /*[5]*/
  z-index: 3; /*[6]*/
  overflow: hidden; /*[7]*/
  transition: .5s; /*[8]*/
  transition-delay: .5s; /*[8]*/
}

/* This section creates the nav for the desktop site. Its positioned onto the
mobile nav (which is still acting as backdrop  – this may can be refactored in
the future. It's arranged to center by positioning, the z-index  ensures that
it displays on top of the other nav. The media query ensures that it only
triggers on desktop.   The default display: none state ensure that it won't
even render on mobile.) 

The sitename, the hamburger icon and the mobile link list are hidden  using
display none and media queries. They can be found alongside their respective
mobile parts. */

.header-main__nav-desktop {
  display: none;
}

@media (min-width: 768px){
  .header-main__nav-desktop {
    display: block;
    background: gold;
    position: absolute;
    z-index: 6;
    top: 40px;
    left: 30%;
    right: 30%;
    text-align: center;
  }

  .header-main__link-desktop {
    display: inline-block;
    padding: 0 2%;
  }
}

/**
* [9] The site's name or logo can live in this
* element. It's absolutely positioned to the left
* side of the header and its z-index puts it to
* the top of the stack.
*
* The font-size is important –it has to match
* the height of the hamburger icon for us to be
* able to align it correctly. Also the position
* from top is determined by the hamburger icon.
*/

.header-main__sitename { /*[9]*/
  position: absolute;
  top: 40px;
  left: 40px;
  font-size: 20px;
  z-index: 6;
}

/* Hides the sitename on desktop. */

@media (min-width: 768px) {
  
  .header-main__sitename {
    display: none;
  }

}

/**
* [10] The label will act as one part of the pure
* CSS hamburger icon. This will be the clickable
* box. Its positioned to the top right corner
* on the same line as the h1. Its height
* is matched to the height of the h1 and
* the z-index is lower by one. The reason:
* we want the spans to sit on top of this label.
*
*/

.header-main__hamburger-icon { /*[10]*/
  position: absolute;
  top: 40px;
  right: 40px;
  height: 20px;
  width: 15px;
  z-index: 5;
}

.header-main__hamburger-icon:hover {
  cursor: pointer;
}

/* Hides the hamburger label on desktop. */

@media (min-width: 768px) {
  
  .header-main__hamburger-icon {
    display: none;
  }

}

/**
* [11] The icon itself is 3 span elements combined.
* [12] The position: absolute; positions the spans
* relative to their parent, the label element.
* [13] Their width is the same as the containing
* label's.
* [14] Their z-index is the same as the h1's.
* [15] The block / height / background trio creates
* the lines themselves.
* [16] The transition property will become useful
* later when we want to animate the icon.
*/

.header-main__icon-element { /*[11]*/
  display: block; /*[15]*/
  position: absolute; /*[12]*/
  top: 50%; /*[12]*/
  left: 0; /*[12]*/
  width: 100%; /*[13]*/
  height: 2px; /*[15]*/
  z-index: 6; /*[14]*/
  background: #000; /*[15]*/
  transition: .5s; /*[16]*/
}

/* Hides the hamburger spans on desktop. */

@media (min-width: 768px) {
  
  .header-main__icon-element {
    display: none;
  }

}

/**
* [17] Moves the first span upwards.
* [18] Moves the last span downwards. These two
* form the hamburger icon itself.
*
* The spacing between the lines is even.
*
*/

.header-main__icon-element--first { /*[17]*/
  top: 25%;
}

.header-main__icon-element--last { /*[18]*/
  top: 75%;
}

/**
* This is the where things get interesting. :)
* We want the hamburger to transform to an X when
* clicked then transform back. The code below does
* just that by manipulating the span elements.
*
* [19] Brings all the spans to the center of the
* label and hides them with opacity:0;
* [20] Turns back the opacity of the first span,
* spins it around using rotate and stops it
* in a 45 degree angle.
* [21] Does the same for the last span but spins
* it in the opposite direction.
* [16] The transition: .5s; on the original spans
* gives the hamburger a nice animated effect.
*
*/

.header-main__hidden-checkbox:checked + .header-main__hamburger-icon .header-main__icon-element { /*[19]*/
  opacity: 0;
  top: 50%;
}

.header-main__hidden-checkbox:checked + .header-main__hamburger-icon .header-main__icon-element--first { /*[20]*/
  opacity: 1;
  transform: rotate(405deg);
}

.header-main__hidden-checkbox:checked + .header-main__hamburger-icon .header-main__icon-element--last { /*[21]*/
  opacity: 1;
  transform: rotate(-405deg);
}

/**
* Now we have a working hamburger menu, time to define what will happen once it's clicked.
* We want the nav to extend itself to the full *height of the viewport and display its links.
*
* [22] This simple height property extends the nav.
* Don't forget that the block that displays the
* headline and the hamburger _is the nav_.
* Everything is positioned on top of it. It has
* a 100px height by default which will be overriden
* once the user clicks the menu icon. This is
* why it has a lower z-index than everything else.
*
*/

.header-main__hidden-checkbox:checked ~ .header-main__nav-mobile {
  height: 100vh; /*[22]*/
  transition: .5s;
}

/*
* [23] The link list needs to be moved down to
* the center of the open full-height nav.
* We solve this by a position absolute
* which arranges the list relative to the nav.
* 
* [24] The .header-main__link-list is positioned
* outside of the viewport in closed stance to
* solve the bug where there was an invisible but
* clickable box which could freeze the whole nav.
* It's positioned correctly when the checkbox is 
* clicked.
* 
*/

.header-main__link-list { /*[23]*/
  position: absolute;
  top: -2000px; /*[24]*/
  left: 20%;
  right: 20%;
}

/* Hides the mobile links on desktop. */

@media (min-width: 768px) {

  .header-main__link-list {
    display: none;
  }

}

/*
* [25] The links are hidden by default then
* when the checkbox is ticked their opacity
* is set to 1 with a delayed transition.
*
*/

.header-main__link-mobile { /*[25]*/
  opacity: 0;
  color: #000;
  display: block;
  text-align: center;
  text-decoration: none;
  text-transform: uppercase;
  font-family: sans-serif;
  padding: 30px;
  transition: .5s;
}

.header-main__hidden-checkbox:checked ~ .header-main__nav-mobile > .header-main__link-list {
  top: 35%; /*[24]*/
}

.header-main__hidden-checkbox:checked ~ .header-main__nav-mobile > .header-main__link-list > .header-main__link-mobile { /*[25]*/
  opacity: 1;
  transition-delay: .5s;
}





/*------------------------------------*\
  #FOOTER-STYLES
\*------------------------------------*/

.footer-main__nav, 
.footer-main__social-icon-row {
  margin-bottom: 1.5rem;
}

.footer-main__copyright {
  margin-bottom: 0;
}






/* ===================================================== */



.list-test { /* temporary proof of concept. not really working on smaller viewports. */
  margin: 0 auto;
  width: 35%;
  background: rebeccapurple;
  list-style: none;
}



